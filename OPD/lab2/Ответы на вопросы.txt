1) При выполнении команд INC и DEC флаги сбрасываются 
и устанавливаются исходя из полученного значения 
в аккумуляторе, т.е С=1 при выходе за 
разрядную сетку, переносе из старшего разряда, 
и V=1 при знаковом переполнении.

2) Оба флага обновляются после команды ADD исходя
из результата в AC, и оба сигнализируют о некотором
переполнении в числе. Только флаг C сигнализирует
о том, что результат суммы получился больше
максимально возможного для данной разрядной сетки,
а флаг V сигнализирует о переходе положительных
чисел в отрицательные или наоборот, из-за
ограничения максимально большим положительным 
и максимально маленьким отрицательным числами.
Для суммы чисел флаг C равен 1, если
результат вышел за размеры разрядной сетки.
Флаг V для суммы будет равен 1 в случае утери знака,
например когда при сложении двух положительных или
двух отрицательных результат получается отрицательный
или положительный соответственно

3) В Big Endian старший байт значения будет хранится 
по младшему адресу, из за чего в памяти это значение
будет читаться легко, так как оно будет записано
в том же порядке что изначально(слева направо), но
для арифметических операций будет не так удобно
В Little Endian старший байт записывается 
по старшему адресу, из за чего оно станет читаться
справа налево. Это бдет менее интуитивно понятно для
человека, но для компьютера будет легко производить 
арифметические операции.
Для Middle Endian байты меняются внутри пар,
что соблюдает некоторый баланс при использовании,
так как сами пары остаются в читаемом порядке,
а вот значения внутри них меняются местами.
Но этот формат не стандартный, плоосоввместим
и исползуется редко.

4)При выполнении команды ASL в регистр DR
записывается значение из AC до выполнения сдвига
и сохраняется там

5)(Instruction Fetch)
Такт 1: 
IP → AR, MEM[IP] → DR → CR, IP++
(Address/Operand Fetch)
Такт 2:
AR = sign-extend(CR[0:7]) = 123 (07B), 
MEM[AR] → DR
Такт 3:
DR → AR, MEM[AR]→DR
(Execution)
Такт 4:
~AC & ~DR → BR, ~BR → AC

6)По сути операции AND и OR это побитовое 
умножение и сложение соответсвенно, при котором 
не возникает переноса, так как при умножении
мы перемножаем последовательно каждый бит, 
и переноса из старшего разряда никак не 
произойдет, а при сложении мы учитываем только 
результат в этом бите без переноса в следующий.
Поэтому Флаг С не изменится и сохранит свое
предыдущее значение.
Так как эти команды оперируют числами в
беззнаковом представлении, так как мы не 
учитываем знак в ходе выполнения операции 
то не произойдет переполнения для флага V, 
поэтому он всегда будет устанавливаться в 0.

7)Хоть память на основе SRAM и будет намного 
быстрее памяти DRAM, но не получится обойтись 
только памятью SRAM из за ее низкой плотности,
и высокой стоимости. Обычно память SRAM хранит
небольшое количество информации которое нужно 
здесь и сейчас для быстрой обработки, работая
на основе нескольких транзисторов.
Память DRAM имеет намного более высокую плотность,
из-за использвания конденсаторов в схемах,
что позволит уместить в тысячи раз больше
информации на небольших схемах. Такая память
обойдется намного дешевле, и будет полезна
для хранения временной информации в сильно 
больших объемах.
Поэтому стараются совмещать оба вида памяти,
для разных задач компьютера.
